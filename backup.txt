
package main

import (
	"fmt"
	"math/rand"
	"strings"
	"time"

	"github.com/gdamore/tcell/v2"
)

// Player represents a gladiator with stats and abilities
type Player struct {
	Name      string
	Health    int
	MaxHealth int
	AttackMin int
	AttackMax int
	Wins      int
}

// BattleResult contains the outcome of an attack
type BattleResult struct {
	Attacker   *Player
	Defender   *Player
	Damage     int
	IsCritical bool
	IsBlocked  bool
	IsGameOver bool
	WinnerName string
}

// Constants for game configuration
const (
	criticalChance = 10 // 1 in 10 chance (10%)
	blockChance    = 10 // 1 in 10 chance (10%)
	turnDelay      = 800 * time.Millisecond
	maxLogEntries  = 20
)

// randRange returns a random number between min and max (inclusive)
func randRange(min, max int) int {
	return rand.Intn(max-min+1) + min
}

// calculateDamage determines attack damage with critical hits and blocks
func calculateDamage(attacker, defender *Player) BattleResult {
	damage := randRange(attacker.AttackMin, attacker.AttackMax)
	isCritical := rand.Intn(criticalChance) == 0
	isBlocked := rand.Intn(blockChance) == 0

	if isCritical {
		damage *= 2
	}
	if isBlocked {
		damage /= 2
	}

	defender.Health -= damage
	isGameOver := defender.Health <= 0

	// Ensure health doesn't go below zero for display purposes
	if defender.Health < 0 {
		defender.Health = 0
	}

	var winnerName string
	if isGameOver {
		winnerName = attacker.Name
		attacker.Wins++
	}

	return BattleResult{
		Attacker:   attacker,
		Defender:   defender,
		Damage:     damage,
		IsCritical: isCritical,
		IsBlocked:  isBlocked,
		IsGameOver: isGameOver,
		WinnerName: winnerName,
	}
}

// formatBattleMessage creates a descriptive message for the battle log
func formatBattleMessage(result BattleResult) string {
	msg := fmt.Sprintf("%s strikes %s for %d damage! (%s HP: %d/%d)",
		result.Attacker.Name, result.Defender.Name, result.Damage,
		result.Defender.Name, result.Defender.Health, result.Defender.MaxHealth)

	if result.IsCritical {
		msg += " ðŸ’¥ CRITICAL HIT!"
	}
	if result.IsBlocked {
		msg += " ðŸ›¡ï¸ BLOCKED!"
	}

	return msg
}

// fight handles the battle loop between two players
func fight(p1, p2 *Player, screen tcell.Screen, quit chan bool, done chan bool) {
	battleLog := []string{
		"ðŸ”¥ GLADIATOR BATTLE ðŸ”¥",
		fmt.Sprintf("%s vs %s", p1.Name, p2.Name),
		"",
	}

	drawUI(screen, p1, p2, battleLog, false)
	time.Sleep(turnDelay)

	turn := 0

	for p1.Health > 0 && p2.Health > 0 {
		select {
		case <-quit:
			return // Exit if user presses 'q'
		default:
			// Determine attacker and defender based on turn
			attacker, defender := p1, p2
			if turn%2 == 1 {
				attacker, defender = p2, p1
			}

			// Calculate damage and update health
			result := calculateDamage(attacker, defender)
			battleLog = append(battleLog, formatBattleMessage(result))

			// Check for game over
			if result.IsGameOver {
				battleLog = append(battleLog, "")
				battleLog = append(battleLog, fmt.Sprintf("ðŸ† %s is VICTORIOUS! ðŸ†", result.WinnerName))
				drawUI(screen, p1, p2, battleLog, true)
				done <- true
				return
			}

			turn++
			drawUI(screen, p1, p2, battleLog, false)
			time.Sleep(turnDelay)
		}
	}
}

// drawHealthBar creates a visual health bar
func drawHealthBar(current, max int, width int) string {
	if max <= 0 {
		return "[ERROR]"
	}

	filledWidth := int(float64(current) / float64(max) * float64(width))
	if filledWidth < 0 {
		filledWidth = 0
	}

	bar := "["
	bar += strings.Repeat("â–ˆ", filledWidth)
	bar += strings.Repeat(" ", width-filledWidth)
	bar += "]"

	return bar
}

// drawUI renders the game interface to the screen
func drawUI(screen tcell.Screen, p1, p2 *Player, log []string, gameOver bool) {
	screen.Clear()

	// Helper function to draw text
	printText := func(x, y int, text string, style tcell.Style) {
		for i, c := range text {
			screen.SetContent(x+i, y, c, nil, style)
		}
	}

	// Define styles
	defaultStyle := tcell.StyleDefault
	titleStyle := defaultStyle.Bold(true).Foreground(tcell.ColorYellow)
	playerStyle := defaultStyle.Foreground(tcell.ColorGreen)
	enemyStyle := defaultStyle.Foreground(tcell.ColorRed)
	infoStyle := defaultStyle.Foreground(tcell.ColorYellow)

	// Draw title and stats
	printText(2, 1, "GLADIATOR ARENA", titleStyle)

	// Draw player stats with health bars
	healthBarWidth := 20
	p1HealthBar := drawHealthBar(p1.Health, p1.MaxHealth, healthBarWidth)
	p2HealthBar := drawHealthBar(p2.Health, p2.MaxHealth, healthBarWidth)

	printText(2, 3, fmt.Sprintf("%s", p1.Name), playerStyle)
	printText(2, 4, fmt.Sprintf("HP: %d/%d %s", p1.Health, p1.MaxHealth, p1HealthBar), playerStyle)
	printText(2, 5, fmt.Sprintf("ATK: %d-%d | Wins: %d", p1.AttackMin, p1.AttackMax, p1.Wins), playerStyle)

	printText(2, 7, fmt.Sprintf("%s", p2.Name), enemyStyle)
	printText(2, 8, fmt.Sprintf("HP: %d/%d %s", p2.Health, p2.MaxHealth, p2HealthBar), enemyStyle)
	printText(2, 9, fmt.Sprintf("ATK: %d-%d | Wins: %d", p2.AttackMin, p2.AttackMax, p2.Wins), enemyStyle)

	// Draw battle log with scrolling
	printText(2, 11, "BATTLE LOG:", titleStyle)

	startY := 12
	displayLog := log
	if len(log) > maxLogEntries {
		displayLog = log[len(log)-maxLogEntries:]
	}

	for i, line := range displayLog {
		printText(2, startY+i, line, defaultStyle)
	}

	// Show controls
	controlsY := startY + len(displayLog) + 2
	if gameOver {
		printText(2, controlsY, "Game Over! Press 'q' to exit or 'r' to fight again.", infoStyle)
	} else {
		printText(2, controlsY, "Press 'q' to quit.", infoStyle)
	}

	screen.Show()
}

// resetPlayers prepares players for a new battle
func resetPlayers(p1, p2 *Player) {
	p1.Health = p1.MaxHealth
	p2.Health = p2.MaxHealth
}

// main is the entry point of the program
func main() {
	rand.Seed(time.Now().UnixNano())

	// Create players with balanced stats
	hero := &Player{
		Name:      "Hero",
		Health:    100,
		MaxHealth: 100,
		AttackMin: 8,
		AttackMax: 15,
		Wins:      0,
	}

	villain := &Player{
		Name:      "Villain",
		Health:    100,
		MaxHealth: 100,
		AttackMin: 10,
		AttackMax: 12,
		Wins:      0,
	}

	// Initialize terminal UI
	screen, err := tcell.NewScreen()
	if err != nil {
		fmt.Println("Error creating screen:", err)
		return
	}
	defer screen.Fini()

	if err := screen.Init(); err != nil {
		fmt.Println("Error initializing screen:", err)
		return
	}

	screen.Clear()

	// Channels for game control
	quit := make(chan bool)
	done := make(chan bool)

	// Start input handler
	go func() {
		for {
			ev := screen.PollEvent()
			switch ev := ev.(type) {
			case *tcell.EventKey:
				if ev.Key() == tcell.KeyRune {
					switch ev.Rune() {
					case 'q':
						quit <- true
						return
					case 'r':
						// Only allow restart after a battle is complete
						select {
						case <-done:
							resetPlayers(hero, villain)
							go fight(hero, villain, screen, quit, done)
						default:
							// Battle still in progress, do nothing
						}
					}
				} else if ev.Key() == tcell.KeyEscape {
					quit <- true
					return
				}
			case *tcell.EventResize:
				screen.Sync()
			}
		}
	}()

	// Start first battle
	go fight(hero, villain, screen, quit, done)

	// Wait for quit signal
	<-quit
}
